{"version":3,"sources":["common.js","t.js","types.js","r.js"],"names":["CODE","Math","random","BuiltIns","Symbol","Boolean","Number","String","Object","Set","Map","WeakMap","WeakSet","Uint8Array","Uint16Array","Uint32Array","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Uint8ClampedArray","Node","NodeList","Element","HTMLElement","Blob","ArrayBuffer","FileList","Text","HTMLDocument","Document","DocumentFragment","Error","File","Event","EventTarget","URL","DEBUG","SEALED_DEFAULT","isNone","instance","undefined","typeCache","T","parts","vals","cooked","typeName","reduce","prev","cur","i","has","TypeError","get","type","partialMatch","validate","partial","guardType","guardExists","name","spec","kind","help","verify","verifiers","sealed","specKeyPaths","allKeyPaths","sort","specKeyPathSet","bigErrors","allValid","keyPaths","every","kp","lookup","checkTypeMatch","resolved","lookupErrors","errors","push","length","keyType","Type","error","valid","validationErrors","verified","JSON","stringify","map","f","toString","join","isSumType","types","keys","t","helpMsg","e","sealValid","type_key_paths","all_key_paths","errorKeys","tkp","k","container","containerValid","containerErrors","membersValid","member","check","obj","keyPath","canBeNone","split","pathComplete","nextKey","shift","typeA","typeB","startsWith","console","option","sub","defSub","native","newType","def","defEnum","guardRedefinition","values","valueSet","exists","o","isTypeSpec","recurseObject","keyPathSet","lastLevel","levelKeys","getOwnPropertyNames","forEach","v","add","Array","isArray","warn","item","index","defOption","isUnset","maybe","defCollection","set","defTuple","pattern","specObj","key","mods","defineProperty","typeSet","cache","defOr","some","guard","originalName","mapBuiltins","constructor","defineSpecials","Function","isInteger","iterator","oName","prototype","call","replace","endsWith","self","for","TKey","THandlers","eventNames","handlerFuncs","validNames","validFuncs","func","TFuncArray","TEmptyArray","TMarkupObject","code","nodes","externals","TMarkupAttrObject","str","TBrutalLikeObject","to","update","TBrutalObject","TBrutalArray","TSBrutalObject","handlers","TSBrutalArray","BS","SSR","Types","skip","markup","attrskip","attrmarkup","NULLFUNC","KEYMATCH","ATTRMATCH","KEYLEN","XSS","OBJ","UNSET","INSERT","NOTFOUND","loc","MOVE","frag","elem","appendChild","parentNode","insertBefore","nextSibling","replaceChild","firstChild","innerHTML","onerror","log","message","stack","isKey","isHandlers","d","R","u","X","p","dumbass","useCache","instanceKey","cacheKey","guardAndTransformVal","find","isCached","cached","firstCall","vmap","V","replaceValWithKeyAndOmitInstanceKey","toDOM","walker","document","createTreeWalker","NodeFilter","SHOW_ALL","makeUpdaters","nextNode","retVal","childNodes","instances","location","options","position","toLocaleLowerCase","createDocumentFragment","n","isNode","querySelector","die","node","currentNode","nodeType","ELEMENT_NODE","handleElement","COMMENT_NODE","TEXT_NODE","handleNode","result","lengths","text","nodeValue","exec","val","replacer","makeNodeUpdater","replacers","nodeState","scope","assign","oldVal","oldNodes","lastAnchor","newVal","getType","handleMarkupInNode","handleTextInNode","state","from","reverse","placeholderNode","summonPlaceholder","dn","diffNodes","size","valIndex","vi","originalLengthBefore","slice","lengthBefore","sum","x","value","correction","newValue","getAttributes","attrState","lastIndex","prepareAttributeUpdater","updateName","input","oldName","makeAttributeNameUpdater","makeAttributeValueUpdater","attr","hasAttribute","removeAttribute","trim","test","assignmentIndex","indexOf","reliablySetAttribute","updateAttrWithFuncarrayValue","updateAttrWithFunctionValue","updateAttrWithHandlersValue","updateAttrWithTextValue","nodesToStr","setAttribute","formatClassListValue","getAttribute","attributes","attrs","flags","includes","O","removeEventListener","addEventListener","splice","of","entries","eventName","funcVal","zeroWidthCorrection","newAttrValue","before","after","spacer","sibling","ph","guardEmptyHandlers","padEnd","templateEl","DOMParser","parseFromString","head","firstElementChild","HTMLTemplateElement","content","normalize","isFunc","isObject","isBrutalArray","isFuncArray","isMarkupObject","isMarkupAttrObject","isBrutal","isForgery","os","bigNodes","cloneNode","createElement","last","next","filter","newVals","msg","err","s","showNodes","info","out","nodeName","toLowerCase","children","innerText"],"mappings":"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","file":"r.js","sourceRoot":"..","sourcesContent":["// common for all r submodules\n  export const CODE              = ''+Math.random();\n\n","\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n    FileList, Text, HTMLDocument, Document, DocumentFragment,\n    Error, File, Event, EventTarget, URL\n  ]\n\n  const DEBUG = false;\n  const SEALED_DEFAULT = true;\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  T.def = def;\n  T.check = check;\n  T.sub = sub;\n  T.verify = verify;\n  T.validate = validate;\n  T.partialMatch = partialMatch;\n  T.defEnum = defEnum;\n  T.defSub = defSub;\n  T.defTuple = defTuple;\n  T.defCollection = defCollection;\n  T.defOr = defOr;\n  T.option = option;\n  T.defOption = defOption;\n  T.maybe = maybe;\n  T.guard = guard;\n  T.errors = errors;\n\n  // debug\n  if ( DEBUG ) {\n    self.T = T;\n    self.typeCache = typeCache;\n  }\n\n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  export function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return typeCache.get(typeName).type;\n  }\n\n  function partialMatch(type, instance) {\n    return validate(type, instance, {partial:true});\n  }\n\n  function validate(type, instance, {partial: partial = false} = {}) {\n    guardType(type);\n    guardExists(type);\n    const typeName = type.name;\n\n    const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n    const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n    const specKeyPathSet = new Set(specKeyPaths);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( spec ) {\n          const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            // Allow lookup errors if the type match for the key path can include None\n\n            const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n            bigErrors.push(...lookupErrors);\n\n            if ( lookupErrors.length ) return false;\n\n            const keyType = lookup(spec,kp).resolved;\n            if ( !keyType || !(keyType instanceof Type) ) {\n              bigErrors.push({\n                error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n              });\n              return false;\n            }\n\n            const {valid, errors: validationErrors} = validate(keyType, resolved);\n            bigErrors.push(...validationErrors);\n\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( partial && ! spec && !!verify ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n            ` only use a verify function but have no spec`);\n        } else if ( verify ) {\n          try {\n            verified = verify(instance);\n            if ( ! verified ) {\n              if ( verifiers ) {\n                throw {\n                  error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                };\n              } else if ( type.isSumType ) {\n                throw {\n                  error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                  verify, verifiers\n                }\n              } else {\n                let helpMsg = '';\n                if ( help ) {\n                  helpMsg = `Help: ${help}. `;\n                }\n                throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n              }\n            }\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed && !! spec ) {\n          const type_key_paths = specKeyPaths;\n          const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n          sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n          if ( ! sealValid ) {\n            if ( all_key_paths.length < type_key_paths.length ) {\n              sealValid = true;\n            } else {\n              const errorKeys = [];\n              const tkp = new Set(type_key_paths); \n              for( const k of all_key_paths ) {\n                if ( ! tkp.has(k) ) {\n                  errorKeys.push({\n                    error: `Key path '${k}' is not in the spec for type ${typeName}`\n                  });\n                }\n              }\n              if ( errorKeys.length ) {\n                bigErrors.push(...errorKeys);\n              }\n            }\n          }\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        let membersValid = true;\n        let verified = true;\n\n        bigErrors.push(...containerErrors);\n        if ( partial ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n        } else {\n          if ( containerValid ) {\n             membersValid= [...instance].every(member => {\n              const {valid, errors} = validate(spec.member, member);\n              bigErrors.push(...errors);\n              return valid;\n            });\n          }\n          if ( verify ) {\n            try {\n              verified = verify(instance);\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n        }\n          \n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath, canBeNone) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( (resolved === null || resolved === undefined) ) {\n        if ( keys.length ) {\n          errors.push({\n            error: \n              `Lookup on key path '${keyPath}' failed at '` + \n              pathComplete.join('.') +\n              `' when ${resolved} was found at '${nextKey}'.` \n          });\n        } else if ( !!canBeNone && canBeNone() ) {\n          resolved = undefined;\n        } else {\n          errors.push({\n            error: \n              `Resolution on key path '${keyPath}' failed` + \n              `when ${resolved} was found at '${nextKey}' and the Type of this` +\n              `key's value cannot be None.`\n          });\n        }\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function checkTypeMatch(typeA, typeB) {\n    guardType(typeA);\n    guardExists(typeA);\n    guardType(typeB);\n    guardExists(typeB);\n\n    if ( typeA === typeB ) {\n      return true;\n    } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n      return true;\n    } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n      return true;\n    } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n      return true;\n    } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n      return true;\n    }\n\n    if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n      console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n    }\n\n    return false;\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n    guardType(type);\n    guardExists(type);\n\n    let verifiers;\n\n    if ( ! verify ) {\n      verify = () => true;\n    } \n\n    if ( type.native ) {\n      verifiers = [ {help,verify} ];\n      verify = i => i instanceof type.native;\n      const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n      verifiers.push({help:helpMsg,verify});\n    }\n\n    const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n    return newType;\n  }\n\n  function defEnum(name, ...values) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n    \n    const valueSet = new Set(values);\n    const verify = i => valueSet.has(i);\n    const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n    return def(name, null, {verify,help});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o, specKeyPaths) {\n    const isTypeSpec = ! specKeyPaths;\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths, '');\n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const keyPaths = levelKeys\n        .map(k => lastLevel + (lastLevel.length ? '.' : '') + k)\n      levelKeys.forEach((k,i) => {\n        const v = o[k];\n        if ( isTypeSpec ) {\n          if ( v instanceof Type ) {\n            keyPathSet.add(keyPaths[i]);\n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              DEBUG && console.warn({o,v,keyPathSet, lastLevel});\n              throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n            }\n          } else {\n            throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n          }\n        } else {\n          if ( specKeyPaths.has(keyPaths[i]) ) {\n            keyPathSet.add(keyPaths[i]); \n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n              //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n            }\n          } else {\n            //console.warn(\"Spec has no such key\",  keyPaths[i]);\n            keyPathSet.add(keyPaths[i]);\n          }\n        }\n      });\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function maybe(type) {\n    try {\n      return defOption(type);\n    } catch(e) {\n      // console.log(`Option Type ${type.name} already declared.`, e);\n    }\n    return T`?${type.name}`;\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const t = new Type(name);\n    const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const t = new Type(name);\n    const spec = {kind, spec: specObj, type:t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n\n    if ( mods.types ) {\n      const {types} = mods;\n      const typeSet = new Set(types);\n      Object.defineProperty(this,'isSumType', {get: () => true});\n      Object.defineProperty(this,'types', {get: () => typeSet});\n    }\n\n    if ( mods.native ) {\n      const {native} = mods;\n      Object.defineProperty(this,'native', {get: () => native});\n    }\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.typeName} Type`;\n  };\n\n  function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    if ( name.startsWith('?') ) {\n      if ( spec ) {\n        throw new TypeError(`Option type can not have a spec.`);\n      } \n\n      if ( ! verify(null) ) {\n        throw new TypeError(`Option type must be OK to be unset.`);\n      }\n    }\n\n    const kind = 'def';\n    if ( sealed === undefined ) {\n      sealed = true;\n    }\n    const t = new Type(name, {types, native});\n    const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n    typeCache.set(name, cache);\n    return t;\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    //console.log(t);\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: () => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n","// types\n  import {T} from './t.js';\n  import {CODE} from './common.js';\n\n  // T\n\n    export default T;\n\n  // Both SSR and Browser\n\n    export const TKey = T.def('Key', {\n      key: T.defOr('ValidKey', T`String`, T`Number`)\n    });\n\n    export const THandlers = T.def('Handlers', null, {verify: i => {\n      const validObject = T.check(T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => T.check(T`String`, name));\n      const validFuncs = handlerFuncs.every(func => T.check(T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    export const TFuncArray = T.defCollection('FuncArray', {\n      container: T`Array`,\n      member: T`Function`\n    });\n\n    export const TEmptyArray = T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    export const TMarkupObject = T.def('MarkupObject', {\n      type: T`String`,\n      code: T`String`,\n      nodes: T`Array`,\n      externals: T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == CODE});\n\n    export const TMarkupAttrObject = T.def('MarkupAttrObject', {\n      type: T`String`,\n      code: T`String`,\n      str: T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == CODE});\n\n  // Browser side\n\n    export const TBrutalLikeObject = T.def('BrutalLikeObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`\n    });\n\n    export const TBrutalObject = T.def('BrutalObject', {\n      code: T`String`,\n      externals: T`Array`,\n      nodes: T`Array`,\n      to: T`Function`,\n      update: T`Function`,\n      v: T`Array`\n    }, {verify: v => verify(v)});\n\n    export const TBrutalArray = T.defCollection('BrutalArray', {\n      container: T`Array`,\n      member: T`BrutalObject`\n    });\n\n  // SSR\n\n    export const TSBrutalObject = T.def('SBrutalObject', {\n      str: T`String`,\n      handlers: THandlers\n    });\n\n    export const TSBrutalArray = T.defCollection('SBrutalArray', {\n      container: T`Array`,\n      member: T`SBrutalObject`\n    });\n\n  // export\n\n  export const BS = {TKey,THandlers,TFuncArray,TBrutalObject,TBrutalLikeObject,TBrutalArray};\n\n  export const SSR = {TKey,THandlers,TFuncArray,TSBrutalObject,TSBrutalArray};\n\n  export const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return CODE === v.code;\n    }\n\n","// r.js\n  // imports\n    import {CODE} from './common.js';\n    import T from './types.js';\n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n    };\n\n  // logging\n    self.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => T.check(T`Key`, v);\n    const isHandlers        = v => T.check(T`Handlers`, v);\n\n  // cache \n    const cache = {};\n    export const d = R;\n    export const u = X;\n\n  // main exports \n    Object.assign(R,{s,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    if ( DEBUG ) {\n      Object.assign(self, {d,u,T}); \n    }\n\n    export function R(p,...v) {\n      return dumbass(p,v);\n    }\n\n    export function X(p,...v) {\n      return dumbass(p,v,{useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function dumbass(p,v,{useCache:useCache=true}={}) {\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        }\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      const retVal = {externals,v:Object.values(vmap),to,\n        update,code:CODE,nodes:[...frag.childNodes]};\n\n      if ( useCache ) {\n        if ( instanceKey ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = T.check(T`>Node`, location);\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.log({location,options,e,elem,isNode});\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"brutalobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          Array.from(newVal.nodes).reverse().forEach(n => {\n            lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n            state.lastAnchor = lastAnchor.nextSibling;\n          });\n          state.lastAnchor = newVal.nodes[0];\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"brutalobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && T.check(T`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      try {\n        node.setAttribute(name,value);\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n    }\n\n    function getType(val) {\n      const type = T.check(T`Function`, val) ? 'function' :\n        T.check(T`Handlers`, val) ? 'handlers' : \n        T.check(T`BrutalObject`, val) ? 'brutalobject' : \n        T.check(T`MarkupObject`, val) ? 'markupobject' :\n        T.check(T`MarkupAttrObject`, val) ? 'markupattrobject' :\n        T.check(T`FuncArray`, val) ? 'funcarray' : 'default';\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'brutal-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--brutal-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instanceKey ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instanceKey ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that Brutal treats as markup,\n      // even tho it is NOT a Brutal Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that Brutal treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = T.check(T`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( T.check(T`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( T.check(T`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( T.check(T`BrutalObject`, val) || T.check(T`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const templateEl = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\"\n        ).head.firstElementChild;\n        let f;\n        if ( templateEl instanceof HTMLTemplateElement ) { \n          f = templateEl.content;\n          f.normalize();\n          return f;\n        } else {\n          throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n        }\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = T.check(T`Function`, v);\n        const isUnset         = T.check(T`None`, v);\n        const isObject        = T.check(T`Object`, v);\n        const isBrutalArray   = T.check(T`BrutalArray`, v);\n        const isFuncArray     = T.check(T`FuncArray`, v);\n        const isMarkupObject    = T.check(T`MarkupObject`, v);\n        const isMarkupAttrObject= T.check(T`MarkupAttrObject`, v);\n        const isBrutal        = T.check(T`BrutalObject`, v);\n        const isForgery       = T.check(T`BrutalLikeObject`, v)  && !isBrutal; \n\n        if ( isFunc )         return v;\n        if ( isBrutal )       return v;\n        if ( isKey(v) )       return v;\n        if ( isHandlers(v) )  return v;\n        if ( isBrutalArray )  return join(v); \n        if ( isFuncArray )    return v;\n        if ( isMarkupObject )   return v;\n        if ( isMarkupAttrObject)return v;\n        if ( isUnset )        die({error: UNSET()});\n        if ( isForgery )      die({error: XSS()});\n        if ( isObject )       die({error: OBJ()});\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        os.forEach(o => (externals.push(...o.externals),bigNodes.push(...o.nodes)));\n        //Refers #45. Debug to try to see when node reverse order is introduced.\n        //setTimeout( () => console.log(nodesToStr(bigNodes)), 1000 );\n        const retVal = {v:[],code:CODE,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        this.v.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function s(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( T.check(T`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n"]}